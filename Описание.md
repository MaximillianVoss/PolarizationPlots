
---

````md
# Принцип работы программы

Программа предназначена для моделирования взаимодействия электрона,
вылетающего из атома кристаллической решётки, с окружающими атомами,
а также для расчёта квантово-механических матриц переходов и
энергозависимых спиновых характеристик.

Работа программы разделена на **две логические части**:
1. Геометрическая (кристаллическая решётка + матрицы переходов)
2. Квантово-физическая (интегралы, фазы, поляризация)

---

## 1. Точка входа и запуск интерфейса

При запуске файла `main.py` выполняется:

```python
if __name__ == "__main__":
    App().mainloop()
````

Создаётся экземпляр класса `App`, наследующего `tk.Tk`,
и запускается главный цикл обработки событий Tkinter.

---

## 2. Инициализация интерфейса (`App.__init__`)

В методе `__init__` выполняются следующие действия:

### 2.1. Создание параметров модели

Создаются `tk.Variable`, связанные с физическими и численными параметрами:

**Геометрия и решётка**

* `a` — постоянная решётки (Å)
* `R_bohr` — радиус Бора (Å)
* `alpha` — полярный угол вылета электрона (рад)
* `beta` — азимутальный угол (рад)
* `lattice_radius (n)` — число периодов решётки
* `d_layer` — номер слоя источника
* `auto_n` — флаг автоматического подбора `n`

**Часть 2 (энергетика и поляризация)**

* `Z` — заряд ядра
* `b, c1, c2` — параметры потенциала
* `dr, rmax` — параметры радиальной сетки
* `Emin, Emax` — диапазон энергий
* `Npts` — число точек по энергии
* флаги выбора χ(x) и способа расчёта I₃

---

### 2.2. Создание элементов управления

Для каждого параметра создаётся слайдер с:

* названием,
* кратким пояснением,
* текущим числовым значением.

Используется вспомогательный метод `_make_slider()`.

---

### 2.3. Привязка автопересчёта

При изменении параметров геометрии (`a`, `R_bohr`, `alpha`, `beta`, `d_layer`)
автоматически вызывается метод `_recompute_n()`,
если включён режим `auto_n`.

---

## 3. Автоматический подбор размера решётки (`_recompute_n`)

Метод `_recompute_n()`:

1. Считывает текущие параметры:

   * `a`, `R_bohr`
   * `alpha`, `beta`
   * `d_layer`
2. Вызывает функцию `compute_lattice_n_auto()` из `lattice.py`
3. Функция:

   * вычисляет направление вылета электрона,
   * оценивает максимальное продвижение электрона до слоя `d`,
   * добавляет запас ±5 радиусов Бора,
   * подбирает минимальное `n`, покрывающее эту область,
   * ограничивает число узлов по `max_atoms`
4. Обновляет значение `n` и выводит оценку числа узлов

---

## 4. Левая панель: геометрия и матрицы (`update_output_left`)

### 4.1. Чтение параметров

```python
a, R_bohr, alpha, beta, n
interaction_radius = 5 * R_bohr
```

---

### 4.2. Поиск ближайших атомов (`nearest_atoms`)

Вызывается функция:

```python
atoms = nearest_atoms(a, interaction_radius, alpha, beta, n)
```

Она выполняет:

1. Генерацию решётки в кубе `[-n..n]^3`
2. Перевод углов `(alpha, beta)` в вектор направления
3. Для каждого атома:

   * исключает центральный атом `(0,0,0)`
   * отбрасывает атомы «позади» электрона
   * вычисляет расстояние до траектории
   * отбирает атомы в пределах `5 * R_bohr`
4. Сортирует атомы по продвижению вдоль траектории

Результат — список атомов с метриками:

* координаты,
* расстояние до прямой,
* расстояние до источника,
* продольная координата

---

### 4.3. Построение матриц переходов (`transition_matrices`)

Вызывается:

```python
matrices, inverses = transition_matrices(L_source=1)
```

Функция:

1. Перебирает магнитные числа `L_n ∈ [-L, L]`
2. Для каждого `L_n` строит матрицу переходов `D` размером 2×2
3. Проверяет определитель:

   * если `det ≈ 0` → матрица вырожденная
   * иначе вычисляет `D⁻¹`
4. Возвращает словари `{L_n: D}` и `{L_n: D⁻¹ | None}`

---

### 4.4. Вывод в текстовое окно

В левую панель выводится:

* число найденных атомов,
* первые атомы с расстояниями,
* все матрицы `D` и их обратимость.

---

## 5. Правая панель: Часть 2 (`update_output_right`)

### 5.1. Выбор функции χ(x)

В зависимости от флага:

* `chi_table_interp` — табличная функция Томаса–Ферми
* `chi_default` — экспоненциальная аппроксимация

---

### 5.2. Расчёт энергетической сетки (`compute_grid`)

Функция:

1. Строит логарифмическую сетку энергий
2. Переводит энергию в скорость
3. Для каждой скорости вычисляет интегралы:

   * `I1`, `I2`, `I3`
4. Формирует суммарную фазу:

   ```math
   Φ(E) = I1 + I2 + I3
   ```

---

### 5.3. Спиновые амплитуды (`spin_amplitudes_both`)

Для выбранной матрицы `D`:

1. Строится фазовая матрица:

   ```math
   U(E) = diag(e^{i L Φ}, e^{-i (L+1) Φ})
   ```
2. Вычисляется:

   ```math
   ψ_out = 2 · D⁻¹ · U · D · ψ_in
   ```
3. Рассчитываются вероятности `|ψ|²`
4. Формируются кривые:

   * `P↑ + P↓`
   * `P↑ − P↓`
     для двух начальных состояний

---

### 5.4. Визуализация

С помощью `matplotlib` строятся:

1. Проверочный спектр (норма вероятностей)
2. Средний удвоенный спин

Графики обновляются при изменении параметров.

---

## 6. Итоговая структура вызовов

```
App.mainloop
 ├── __init__
 │    ├── _recompute_n
 │    ├── update_output_left
 │    │     ├── nearest_atoms
 │    │     │     ├── generate_lattice
 │    │     │     ├── spherical_to_cartesian
 │    │     │     └── distance_point_to_line
 │    │     └── transition_matrices
 │    └── update_output_right
 │          ├── compute_grid
 │          │     └── compute_I_components
 │          └── spin_amplitudes_both
```

---

## Заключение

Программа последовательно связывает:

* **геометрию кристалла**,
* **квантовые матрицы переходов**,
* **энергетические интегралы**,
* **спиновые вероятности**,

что позволяет интерактивно исследовать влияние параметров
на поляризацию и спектральные характеристики.

